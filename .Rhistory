#
probVector <- 0
for (i in 1:(length(timePoint) - 1)){
probVector[i] <- probMapping(timePoint[i], timePoint[i + 1], 5, failureTable, uniTimePointWithZero)
}
probVectorM <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorM[i] <- probMapping(timePoint[i], timePoint[i + 1], 5, failureTableModified, uniTimePointWithZero)
}
#
# ----- LowerBound
#
probVectorLower <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorLower[i] <- 0
}
#
# ----- UpperBound
#
probVectorUpper <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorUpper[i] <- 0
}
}
lenLimit <- length(which(probVector < 1))
#       timeDiff <- strptime(paste(currentDate, "/01", sep = ""), "%Y/%m/%d") - strptime(rev(x_midCur), "%Y/%m/%d")
timeDiff <- strptime(endtmp[2], "%Y-%m-%d") - strptime(rev(x_midCur), "%Y/%m/%d")
restrict <- which(timeDiff < 720)
#       est <- sum((rev(n_ship) * probVector)[restrict][1:lenLimit], na.rm = T)
est <- sum((rev(n_ship) * probVector)[1:lenLimit], na.rm = T)
estLower <- sum((rev(n_ship) * probVectorLower)[restrict][1:lenLimit], na.rm = T)
estUpper <- sum((rev(n_ship) * probVectorUpper)[restrict][1:lenLimit], na.rm = T)
#
estM <- sum((rev(n_ship)*probVectorM)[restrict], na.rm = T)
}else{
est = estLower = estUpper = estM = 0
}
Est[num] <- est
EstLower[num] <- estLower
EstUpper[num] <- estUpper
#
# failure rate modified
#
EstM[num] <- estM
}
return(list(Est, EstLower, EstUpper, EstM))
}
# ----- Selection mechanism
selectNi <- function(dataM, YMD, minNi = 5){
n_break <- dataM[[5]]
minY <- dataM[[1]][1]; minM <- dataM[[1]][2]; minD <- dataM[[1]][3]
endMonth <- seq(as.Date(paste(c(YMD, "01"), collapse = "/")), length = 2, by = "months")[2]
x1 <- as.character(seq(as.Date(paste(c(minY, minM, minD), collapse = "/")),
as.Date(endMonth), "months"))
x <- as.character(sapply(x1, function(y){
tmp <- strsplit(y, "-")[[1]]
tmp2 <- paste(tmp[1], tmp[2], sep="/")
return(tmp2)
}))
if (minD != 1){
x <- c(x, YMD)
}
xDate <- x[1:length(x) - 1]
#----- selection mechanism
tmpEst <- 0
tmpLower <- 0
tmpUpper <- 0
tmpTrendmv <- 0
tmpEstM <- 0
if (length(xDate) < 25){
twoPeriod <- length(xDate)
}else{
twoPeriod <- 24
}
for (i in 2:twoPeriod){
tmpStore <- rmaNonparametric(xDate[i], dataM, minNi = minNi)
tmpEst[i] <- sum(tmpStore[[1]])
tmpLower[i] <- sum(tmpStore[[2]])
tmpUpper[i] <- sum(tmpStore[[3]])
tmpTrendmv[i] <- sum(tmpStore[[1]])
tmpEstM[i] <- sum(tmpStore[[4]])
if (i > 10){
mean1 <- mean(n_break[(i - 1):(i - 5)])
mean2 <- mean(n_break[(i - 2):(i - 6)])
mean3 <- mean(n_break[(i - 3):(i - 7)])
mean4 <- mean(n_break[(i - 4):(i - 8)])
mean5 <- mean(n_break[(i - 5):(i - 9)])
#-------------------
ft1 <- mean2 - mean1
ft2 <- mean3 - mean2
ft3 <- mean4 - mean3
ft4 <- mean5 - mean4
ftMean <- mean(c(ft1, ft2, ft3, ft4))
tmpTrendmv[i] <- mean(c(mean1 + ftMean,  sum(tmpStore[[1]])))
}
}
if (length(xDate) > 24){
for (i in 25:length(xDate)){
tmpStore <- rmaNonparametric(xDate[i], dataM, minNi = minNi)
tmpEst[i] <- sum(tmpStore[[1]])
tmpEstM[i] <- sum(tmpStore[[4]])
tmpLower[i] <- sum(tmpStore[[2]])
tmpUpper[i] <- sum(tmpStore[[3]])
#-----
tmpTrendmv[i] <- sum(tmpStore[[1]])
mean1 <- mean(n_break[(i - 1):(i - 5)])
mean2 <- mean(n_break[(i - 2):(i - 6)])
mean3 <- mean(n_break[(i - 3):(i - 7)])
mean4 <- mean(n_break[(i - 4):(i - 8)])
mean5 <- mean(n_break[(i - 5):(i - 9)])
ft1 <- mean2 - mean1
ft2 <- mean3 - mean2
ft3 <- mean4 - mean3
ft4 <- mean5 - mean4
ftMean <- mean(c(ft1, ft2, ft3, ft4))
tmpTrendmv[i] <- mean(c(mean1 + ftMean,  sum(tmpStore[[1]])))
}
}
EstStorage <- matrix(c(tmpEst, tmpLower, tmpUpper, tmpTrendmv, tmpEstM), ncol = 5)
# -----
Est <- EstStorage[, 1]
Lower <- EstStorage[, 2]
Upper <- EstStorage[, 3]
nb <- c(as.numeric(n_break))
#----
MVTrend <- EstStorage[, 4]
EstModified <- EstStorage[, 5]
dataFrame <- data.frame(x = xDate, nb = nb, Est = Est, Lower = Lower, Upper = Upper,
MVTrend = MVTrend, EstModified = EstModified, Empirical = dataM[[6]])
## use time series to let the estimation close to the truth.
## ind is set as 30, because the frequency in time series is set as 12, it need at least 2 period.
ind <- 30
est.ts <- rep(0, nrow(dataFrame))
if (nrow(dataFrame) >= ind){
est.ts[1:(ind - 1)] <- dataFrame[1:(ind - 1), "EstModified"]
#   current <- which(dataFrame[, 1] == currentDate)
current <- nrow(dataFrame)
if (length(current) == 0){
for (r in ind:nrow(dataFrame)){
tmpTab <- dataFrame[1:(r - 1), ]
endD <- as.character(tmpTab[(r - 1), 1])
enddate <- as.numeric(strsplit(endD[length(endD)], "/")[[1]])
breakTS <- ts(tmpTab[, "nb"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitB <- stl(breakTS, s.window="period")
estTS <- ts(tmpTab[, "EstModified"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitE <- stl(estTS, s.window="period")
diffValue <- (fitE$time.series[, "trend"] - fitB$time.series[, "trend"])
dValue <- mean(diffValue[(length(diffValue) - 1):length(diffValue)])
est.ts[r] <- dataFrame[r, "EstModified"] - dValue
}
}else{
for (r in ind:nrow(dataFrame)){
if (r <= current){
tmpTab <- dataFrame[1:(r - 1), ]
endD <- as.character(tmpTab[(r - 1), 1])
enddate <- as.numeric(strsplit(endD[length(endD)], "/")[[1]])
breakTS <- ts(tmpTab[, "nb"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitB <- stl(breakTS, s.window="period")
estTS <- ts(tmpTab[, "EstModified"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitE <- stl(estTS, s.window="period")
diffValue <- (fitE$time.series[, "trend"] - fitB$time.series[, "trend"])
dValue <- mean(diffValue[(length(diffValue) - 1):length(diffValue)])
est.ts[r] <- dataFrame[r, "EstModified"] - dValue
}else{
tmpTab <- dataFrame[1:current, ]
endD <- as.character(tmpTab[current, 1])
enddate <- as.numeric(strsplit(endD[length(endD)], "/")[[1]])
breakTS <- ts(tmpTab[, "nb"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitB <- stl(breakTS, s.window="period")
estTS <- ts(tmpTab[, "EstModified"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitE <- stl(estTS, s.window="period")
diffValue <- (fitE$time.series[, "trend"] - fitB$time.series[, "trend"])
dValue <- mean(diffValue[(length(diffValue) - 1):length(diffValue)])
est.ts[r] <- dataFrame[r, "EstModified"] - dValue
}
}
}
}
neg <- which(est.ts < 0)
if (length(neg) > 0){est.ts[neg] <- 0}
dataFrame <- cbind(dataFrame, EstTs = est.ts)
return(dataFrame)
}
#------
currentDate <- "2015/07" # for simulation
ymd <- "2015/07"        # for last estimation
listfile <- read.csv("C:\\Users\\David79.Tseng\\Dropbox\\David79.Tseng\\git-respository\\rma-forecasting\\rmaInventoryList.csv", header = TRUE)
compName <- as.character(listfile[, 1])
nonAppearIndex <- which(compName %in% dat_com$PartNumber)
compNameAppear <- compName[nonAppearIndex]
t1 = proc.time()
for (pro in 1:length(compNameAppear)){
componentName <- compNameAppear[pro]
tM1 <- proc.time()
dataM <- dataArr(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
tM2 <- proc.time()
tM2 - tM1
if (!is.null(dataM)){
datShipPro <- dataM[[3]]
if (nrow(datShipPro) != 0){
uniqueProduct <- as.character(unique(datShipPro$Product_Name))
#
minY <- dataM[[1]][1]; minM <- dataM[[1]][2]; minD <- dataM[[1]][3]
dataComp_c <- dataM[[2]]
datShipPro <- dataM[[3]]
dat_censored1 <- dataM[[4]]
n_break <- dataM[[5]]
YMD <- ymd
endMonth <- seq(as.Date(paste(c(YMD, "01"), collapse = "/")), length = 2, by = "months")[2]
x1 <- as.character(seq(as.Date(paste(c(minY, minM, minD), collapse = "/")),
as.Date(endMonth), "months"))
x <- as.character(sapply(x1, function(y){
tmp <- strsplit(y, "-")[[1]]
tmp[3] <- "01"
tmp2 <- paste(tmp[1], tmp[2], tmp[3], sep="/")
return(tmp2)
}))
# ----- split the x so that it can match the dat_shipping (because dat_shipping only record the amount by month)
x_split <- 0
for (i in 1:length(x)){
tmp <- strsplit(x[i], "/")[[1]]
x_split[i] <- paste0(tmp[1], tmp[2])
}
x_mid <- sapply(1:length(x), function(i){
tmpd <- strsplit(x[i], "/")[[1]]
tmpd[3] <- "15"
paste(tmpd, collapse = "/")
})
nList <- lapply(1:length(uniqueProduct), function(i){
datShipPro_i <- datShipPro[which(datShipPro$Product_Name == uniqueProduct[i]), ]
n_ship <- sapply(1:(length(x_split)), function(j){
return(max(sum(datShipPro_i[which(datShipPro_i$Shipping_DT == x_split[j]), "Qty"]), 0))
})
return(matrix(n_ship, nrow=1))
})
for (l in 1:length(nList)){
colnames(nList[[l]]) <- x_mid[1:(length(x_mid))]
}
names(nList) <- uniqueProduct
elected <- selectNi(dataM = dataM, YMD = ymd, minNi = 5)
}else{
elected <- matrix(0, ncol = 7, nrow = 0)
}
}else{
elected <- matrix(0, ncol = 7, nrow = 0)
}
}
t2 = proc.time()
t2 - t1
##
probMapping <- function(tpIni, tpEnd, index, ftab, uniTimePointWithZero){
if (tpIni %in% uniTimePointWithZero & tpEnd %in% uniTimePointWithZero){
row1 <- ftab[which(uniTimePointWithZero == tpIni), ]
row2 <- ftab[which(uniTimePointWithZero == tpEnd), ]
f1 <- row1[index]; f2 <- row2[index]
if (f1 == 0){
iniRow1 <- iniRow2 <- which(uniTimePointWithZero == tpIni)
while(ftab[iniRow1, index] == 0){
if (iniRow1 == 1)break
iniRow1 <- iniRow1 - 1
}
while(ftab[iniRow2, index] == 0){
if (iniRow2 == nrow(ftab))break
iniRow2 <- iniRow2 + 1
}
proportion <- (tpIni - uniTimePointWithZero[iniRow1])/(uniTimePointWithZero[iniRow2] - uniTimePointWithZero[iniRow1])
f1 <- ftab[iniRow1, index] + proportion*(max(ftab[iniRow2, index] - ftab[iniRow1, index], 0))
}
#-----
if (f2 == 0){
endRow1 <- endRow2 <- which(uniTimePointWithZero == tpEnd)
while(ftab[endRow1, index] == 0){
if (endRow1 == 1)break
endRow1 <- endRow1 - 1
}
while(ftab[endRow2, index] == 0){
if (endRow2 == nrow(ftab))break
endRow2 <- endRow2 + 1
}
proportion <- (tpEnd - uniTimePointWithZero[endRow1])/(uniTimePointWithZero[endRow2] - uniTimePointWithZero[endRow1])
f2 <- ftab[endRow1, index] + proportion*(max(ftab[endRow2, index] - ftab[endRow1, index], 0))
}
prob <- f2 - f1
}else{
if (length(which(uniTimePointWithZero <= tpIni)) == 0){
iniNear1 <- min(uniTimePointWithZero)
}else{
iniNear1 <- uniTimePointWithZero[max(which(uniTimePointWithZero <= tpIni))]
}
iniNear2 <- uniTimePointWithZero[min(which(uniTimePointWithZero > tpIni))]
#         f11 <- ftab[which(uniTimePoint == iniNear1), index]
#         f12 <- ftab[which(uniTimePoint == iniNear2), index]
f11 <- ftab[which(uniTimePointWithZero == iniNear1), index]
f12 <- ftab[which(uniTimePointWithZero == iniNear2), index]
if (f11 == 0){
iniRow1 <- iniRow2 <- which(uniTimePointWithZero == iniNear1)
###
while(ftab[iniRow1, index] == 0){
if (iniRow1 == 1)break
iniRow1 <- iniRow1 - 1
}
###
while(ftab[iniRow2, index] == 0){
if (iniRow2 == nrow(ftab))break
iniRow2 <- iniRow2 + 1
}
proportion <- (iniNear1 - uniTimePointWithZero[iniRow1])/(uniTimePointWithZero[iniRow2] - uniTimePointWithZero[iniRow1])
f11 <- ftab[iniRow1, index] + proportion*max((ftab[iniRow2, index] - ftab[iniRow1, index]), 0)
}
if (f12 == 0){
iniRow1 <- iniRow2 <- which(uniTimePointWithZero == iniNear2)
while(ftab[iniRow1, index] == 0){
if (iniRow1 == 1)break
iniRow1 <- iniRow1 - 1
}
while(ftab[iniRow2, index] == 0){
if (iniRow2 == nrow(ftab))break
iniRow2 <- iniRow2 + 1
}
proportion <- (iniNear2 - uniTimePointWithZero[iniRow1])/(uniTimePointWithZero[iniRow2] - uniTimePointWithZero[iniRow1])
f12 <- ftab[iniRow1, index] + proportion*max((ftab[iniRow2, index] - ftab[iniRow1, index]), 0)
}
if (length(which(uniTimePointWithZero <= tpIni)) == 0){
proportion <- 1
}else{
proportion <- (tpIni - iniNear1)/(iniNear2 - iniNear1)
}
prob_tpIni <- f11 + proportion*(f12 - f11)
# -----
if (length(which(uniTimePointWithZero <= tpIni)) == 0){
endNear1 <- min(uniTimePointWithZero)
}else{
endNear1 <- uniTimePointWithZero[max(which(uniTimePointWithZero < tpEnd))]
}
endNear2 <- uniTimePointWithZero[min(which(uniTimePointWithZero > tpEnd))]
f21 <- ftab[which(uniTimePointWithZero == endNear1), index]
f22 <- ftab[which(uniTimePointWithZero == endNear2), index]
if (f21 == 0){
endRow1 <- endRow2 <- which(uniTimePointWithZero == endNear1)
while(ftab[endRow1, index] == 0){
if (endRow1 == 1)break
endRow1 <- endRow1 - 1
}
while(ftab[endRow2, index] == 0){
if (endRow2 == nrow(ftab))break
endRow2 <- endRow2 + 1
}
proportion <- (endNear1 - uniTimePointWithZero[endRow1])/(uniTimePointWithZero[endRow2] - uniTimePointWithZero[endRow1])
f21 <- ftab[endRow1, index] + proportion*max((ftab[endRow2, index] - ftab[endRow1, index]), 0)
}
if (f22 == 0){
endRow1 <- endRow2 <- which(uniTimePointWithZero == endNear2)
while(ftab[endRow1, index] == 0){
if (endRow1 == 1)break
endRow1 <- endRow1 - 1
}
while(ftab[endRow2, index] == 0){
if (endRow2 == nrow(ftab))break
endRow2 <- endRow2 + 1
}
proportion <- (endNear2 - uniTimePointWithZero[endRow1])/(uniTimePointWithZero[endRow2] - uniTimePointWithZero[endRow1])
f22 <- ftab[endRow1, index] + proportion*max((ftab[endRow2, index] - ftab[endRow1, index]), 0)
}
if (length(which(uniTimePointWithZero <= tpEnd)) == 0){
proportion <- 1
}else{
proportion <- (tpEnd - endNear1)/(endNear2 - endNear1)
}
prob_tpEnd <- f21 + proportion*(f22 - f21)
prob <- prob_tpEnd - prob_tpIni
}
return(prob)
}
t1 = proc.time()
for (pro in 1:length(compNameAppear)){
componentName <- compNameAppear[pro]
tM1 <- proc.time()
dataM <- dataArr(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
tM2 <- proc.time()
tM2 - tM1
if (!is.null(dataM)){
datShipPro <- dataM[[3]]
if (nrow(datShipPro) != 0){
uniqueProduct <- as.character(unique(datShipPro$Product_Name))
#
minY <- dataM[[1]][1]; minM <- dataM[[1]][2]; minD <- dataM[[1]][3]
dataComp_c <- dataM[[2]]
datShipPro <- dataM[[3]]
dat_censored1 <- dataM[[4]]
n_break <- dataM[[5]]
YMD <- ymd
endMonth <- seq(as.Date(paste(c(YMD, "01"), collapse = "/")), length = 2, by = "months")[2]
x1 <- as.character(seq(as.Date(paste(c(minY, minM, minD), collapse = "/")),
as.Date(endMonth), "months"))
x <- as.character(sapply(x1, function(y){
tmp <- strsplit(y, "-")[[1]]
tmp[3] <- "01"
tmp2 <- paste(tmp[1], tmp[2], tmp[3], sep="/")
return(tmp2)
}))
# ----- split the x so that it can match the dat_shipping (because dat_shipping only record the amount by month)
x_split <- 0
for (i in 1:length(x)){
tmp <- strsplit(x[i], "/")[[1]]
x_split[i] <- paste0(tmp[1], tmp[2])
}
x_mid <- sapply(1:length(x), function(i){
tmpd <- strsplit(x[i], "/")[[1]]
tmpd[3] <- "15"
paste(tmpd, collapse = "/")
})
nList <- lapply(1:length(uniqueProduct), function(i){
datShipPro_i <- datShipPro[which(datShipPro$Product_Name == uniqueProduct[i]), ]
n_ship <- sapply(1:(length(x_split)), function(j){
return(max(sum(datShipPro_i[which(datShipPro_i$Shipping_DT == x_split[j]), "Qty"]), 0))
})
return(matrix(n_ship, nrow=1))
})
for (l in 1:length(nList)){
colnames(nList[[l]]) <- x_mid[1:(length(x_mid))]
}
names(nList) <- uniqueProduct
elected <- selectNi(dataM = dataM, YMD = ymd, minNi = 5)
}else{
elected <- matrix(0, ncol = 7, nrow = 0)
}
}else{
elected <- matrix(0, ncol = 7, nrow = 0)
}
}
t1 = proc.time()
for (pro in 1:length(compNameAppear)){
print(pro/length(compNameAppear))
print(paste(pro, length(compNameAppear), sep = "/"))
componentName <- compNameAppear[pro]
tM1 <- proc.time()
dataM <- dataArr(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
tM2 <- proc.time()
tM2 - tM1
if (!is.null(dataM)){
datShipPro <- dataM[[3]]
if (nrow(datShipPro) != 0){
uniqueProduct <- as.character(unique(datShipPro$Product_Name))
#
minY <- dataM[[1]][1]; minM <- dataM[[1]][2]; minD <- dataM[[1]][3]
dataComp_c <- dataM[[2]]
datShipPro <- dataM[[3]]
dat_censored1 <- dataM[[4]]
n_break <- dataM[[5]]
YMD <- ymd
endMonth <- seq(as.Date(paste(c(YMD, "01"), collapse = "/")), length = 2, by = "months")[2]
x1 <- as.character(seq(as.Date(paste(c(minY, minM, minD), collapse = "/")),
as.Date(endMonth), "months"))
x <- as.character(sapply(x1, function(y){
tmp <- strsplit(y, "-")[[1]]
tmp[3] <- "01"
tmp2 <- paste(tmp[1], tmp[2], tmp[3], sep="/")
return(tmp2)
}))
# ----- split the x so that it can match the dat_shipping (because dat_shipping only record the amount by month)
x_split <- 0
for (i in 1:length(x)){
tmp <- strsplit(x[i], "/")[[1]]
x_split[i] <- paste0(tmp[1], tmp[2])
}
x_mid <- sapply(1:length(x), function(i){
tmpd <- strsplit(x[i], "/")[[1]]
tmpd[3] <- "15"
paste(tmpd, collapse = "/")
})
nList <- lapply(1:length(uniqueProduct), function(i){
datShipPro_i <- datShipPro[which(datShipPro$Product_Name == uniqueProduct[i]), ]
n_ship <- sapply(1:(length(x_split)), function(j){
return(max(sum(datShipPro_i[which(datShipPro_i$Shipping_DT == x_split[j]), "Qty"]), 0))
})
return(matrix(n_ship, nrow=1))
})
for (l in 1:length(nList)){
colnames(nList[[l]]) <- x_mid[1:(length(x_mid))]
}
names(nList) <- uniqueProduct
elected <- selectNi(dataM = dataM, YMD = ymd, minNi = 5)
}else{
elected <- matrix(0, ncol = 7, nrow = 0)
}
}else{
elected <- matrix(0, ncol = 7, nrow = 0)
}
}
library(foreach)
library(doParallel)
if(!require(installr)) {
install.packages("installr"); require(installr)} #load / install+load installr
# using the package:
updateR()
library(foreach)
library(doParallel)
cl <- makeCluster(3)
registerDoParallel(cl)
cl <- makeCluster(4)
registerDoParallel(cl)
library(foreach)
library(doParallel)
cl <- makeCluster(4)
stopCluster(cl)
cl <- makeCluster(4)
registerDoParallel(cl)
stopCluster(cl)
stopCluster(cl)
cl <- makeCluster(4)
registerDoParallel(cl)
stopCluster(cl)
