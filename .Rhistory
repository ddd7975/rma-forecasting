elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
return(elected)
})
})
stopCluster(cl)
componentName
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
elected <- selectNi(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
elected <- selectNi(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametric = rmaNonparametric)
elected <- selectNi2(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
rmaNonparametric <- function(currentDate = currentDate, dataM, alpha = 0.05, minNi = 5, uniqueProduct = uniqueProduct, nList = nList, x_mid = x_mid, x = x){
dataComp_c <- dataM[[2]]
# ----- Make the table, 1st column is time point, 2nd column is attribute.
# ----- 1. attribute = 1 means failure data
# ----- 2. attribute = 2 means censored data in failure sheet
# ----- 3. attribute = 3 means censored data in dat_shipping (need to multiple the amount)
cur <- paste(currentDate, "15", sep = "/")
nListCur <- lapply(1:length(uniqueProduct), function(u){
nList[[u]][1, 1:which(x_mid == cur)]
})
x_midCur <- x_mid[1:which(x_mid == cur)]
xCur <- x[1:which(x_mid == cur)]
endtmp <- seq(as.Date(paste(c(currentDate, "01"), collapse = "/")), length = 2, by = "months")
endCurrent <- endtmp[2]
Est <- EstLower <- EstUpper <- 0
EstM <- EstMw <- 0
outtab <- sapply(1:length(uniqueProduct), function(num){
n_ship <- nListCur[[num]]
proName <- uniqueProduct[num]
##
## for censored
##
lf_nonBroken <- as.numeric(strptime(endCurrent, "%Y-%m-%d") - strptime(x_midCur, "%Y/%m/%d"))
dat_attr3 <- as.data.frame(cbind(lifeTime = lf_nonBroken, attribute = rep("3", length(lf_nonBroken))))
##
## ---- dataComp_c includes all the data, it need to remove the Receive_DT after YMD.
##
dataComp_c_pro <- dataComp_c[which(dataComp_c$Product_Name == proName), ]
part <- which(strptime(endtmp[1], "%Y-%m-%d") - strptime(dataComp_c_pro$Receive_DT, "%Y/%m/%d") > 0)
dataComp_c_part <- dataComp_c_pro[part, ]
if (nrow(dataComp_c_part) >= 3){
lfBreak <- rep(dataComp_c_part$lifeTime, dataComp_c_part$qty)
dat_attr1 <- as.data.frame(cbind(lifeTime = lfBreak, attribute = rep("1", length(lfBreak))))
# to know which month this product is broken
lf_Month <- strptime(endCurrent, "%Y-%m-%d") - strptime(paste(xCur, "01", sep = "/"), "%Y/%m/%d")
belongMonth <- strptime(endCurrent, "%Y-%m-%d") - strptime(dataComp_c_part$MES_Shipping_Dt_withDay, "%Y/%m/%d")
belongTime <- 0
if (length(belongMonth) != 0){
for (i in 1:length(belongMonth)){
belongTime[i] <- lf_nonBroken[max(which(belongMonth[i] <= lf_Month))]
}
}
#
censoredPro <- dat_censored1[which(dat_censored1$Product_Name == proName), ]
if (nrow(censoredPro) != 0){
lf_censored1 <- strptime(rep(currentDate, nrow(censoredPro)), "%Y/%m/%d") - strptime(censoredPro$MES_Shipping_Dt_withDay, "%Y/%m/%d")
##
## ---- Because lf_censored1 is build before input the YMD, so it may include the shipping date after than the YMD, so the value will be negative.
##
lf_censored1_part <- lf_censored1[which(lf_censored1 > 0)]
dat_attr2 <- as.data.frame(cbind(lifeTime = as.numeric(lf_censored1_part), attribute = rep("2", length(lf_censored1_part))))
}else{
dat_attr2 <- NULL
}
tmpTable <- rbind(dat_attr1, dat_attr2, dat_attr3)
tmpTable[, 1] <- as.numeric(as.character(tmpTable[, 1]))
tmpTableOrder <- tmpTable[order(tmpTable[, 1]), ]
ind <- which(strptime(x_mid, "%Y/%m/%d") < strptime(endCurrent, "%Y-%m-%d"))
n <- sum(n_ship[ind])
##
## ----- combine the same lifeTime and same attribute together
##
uniTimePoint <- unique(tmpTableOrder[, 1])
if (uniTimePoint[1] == 0){uniTimePoint <- uniTimePoint[-1]}
failureTable <- matrix(0, ncol = 7, nrow = (length(uniTimePoint) + 1))
failureTable[1, 3] <- n
########
########
########
for (i in 2:(length(uniTimePoint) + 1)){
#for (i in 38:38){
tab <- tmpTableOrder[which(tmpTableOrder[, 1] == uniTimePoint[i - 1]), ]
failureTable[i, 1] <- sum((tab[, 2] == 1))      # di
failureTable[i, 2] <- sum((tab[, 2] == 2))      # ri (in failure data)
# attr == 3
if (3 %in% tab$attribute){
locCensor <- which(lf_nonBroken == tab[1, 1])
nCensor <- n_ship[locCensor]
failureTable[i, 2] <- failureTable[i, 2] + nCensor     # ri (attr 3)
}
}
rownames(failureTable) <- c(0, uniTimePoint)
colnames(failureTable) <- c("di", "ri", "ni", "1-pi", "F(ti)", "Lower", "Upper")
for (l in 1:length(belongTime)){
loc <- which(belongTime[l] == c(0, uniTimePoint))
tmp[l] <- loc
failureTable[loc, 2] <- failureTable[loc, 2] - 1
}
if (min(failureTable[, 2]) < 0){
failureTable[1, 3] <- failureTable[1, 3] - sum(failureTable[which(failureTable[, 2] < 0), 2])
failureTable[which(failureTable[, 2] < 0), 2] <- 0
}
for (i in 2:(length(uniTimePoint) + 1)){
failureTable[i, 3] <- failureTable[i - 1, 3] - sum(failureTable[i - 1, 1] + failureTable[i - 1, 2])    # ni
}
########
########
########
if (min(failureTable[, 3]) < 0){
failureTable[, 3] <- failureTable[, 3] - min(failureTable[, 3])
}
# -----
for (i in 1:nrow(failureTable)){
if (failureTable[i, 1] > 0 & failureTable[i, 3] > 0){
failureTable[i, 4] <- 1 - (failureTable[i, 1] / failureTable[i, 3])
}
}
nonZero <- which(failureTable[, 1] != 0)
if (length(nonZero) == 0){
sti <- 0
fti <- 1
}else{
sti <- numeric(length = length(nonZero) + 1)
sti[1] <- 1
for (j in 2:(length(nonZero) + 1)){
sti[j] <- sti[j - 1] * failureTable[which(rownames(failureTable) == names(nonZero[j - 1])), 4]
}
sti <- sti[-1]
fti <- 1 - sti
}
failureTable[which(failureTable[, 1] != 0), 5] <- fti
nj <- failureTable[which(failureTable[, 1] != 0), 3]
p <- 1 - failureTable[which(failureTable[, 1] != 0), 4]
tmp1 <- p/(n*(1-p))
var_Fti  <- 0
for (i in 1:length(fti)){
var_Fti[i] <- (sti[i])^2*sum(tmp1[1:i])
}
z <- qnorm(1 - alpha)
# ----- 1. log transformation
w <- exp(z*sqrt(var_Fti)/(fti*(1 - fti)))
Fti_Lower <- fti/(fti + (1 - fti)*w)
Fti_Upper <- fti/(fti + (1 - fti)/w)
# ----- 2. large sample (assume it is normal distribution)
#   Fti_Lower <- max(fti - z*sqrt(var_Fti), 0)
#   Fti_Upper <- min(fti + z*sqrt(var_Fti), 1)
failureTable[which(failureTable[, 1] != 0), 6] <- Fti_Lower
failureTable[which(failureTable[, 1] != 0), 7] <- Fti_Upper
failureTable[which(failureTable[, 4] == 0 & failureTable[, 1] > 0), 6:7] <- 1
# ----- If the number of sacrificer are less, it may effect the estimation a lot.(failure probability will too high.)
# ----- It still need discussion.
lastDiLargeN <- which(failureTable[, 3] > minNi & failureTable[, 1] > 0)
if (length(lastDiLargeN) != 0){
for (j in 5:7){
for (m in max(lastDiLargeN):nrow(failureTable)){
failureTable[m, j] <- failureTable[lastDiLargeN[length(lastDiLargeN)], j]
}
}
##
## failureTable has only one di, so the F(ti) will be the same, it will let the prob all be zero.
##
for (j in 5:7){
if (failureTable[1, 1] == 0){
if (length(which(failureTable[, j] > 0)) > 0){
for (r in 2:(min(lastDiLargeN) - 1)){
proportion <- c(0, uniTimePoint)[r]/(c(0, uniTimePoint)[min(lastDiLargeN)])
failureTable[r, 5] <- proportion*failureTable[min(lastDiLargeN), 5]
}
}
}
}
}
## ----- Start to build the process of calculation
## unit: day
## Add the currently ()
timePoint <- rev(c(strptime(endMonth, "%Y-%m-%d") - strptime(colnames(n_ship), "%Y/%m/%d"), 0))
##
## probMapping is a function that can map a given timeRange(tpIni, tpEnd) to failureTable to get the probability.
##
uniTimePointWithZero <- c(0, uniTimePoint)
timePoint <- c(0, rev(lf_nonBroken))
failureTableModified <- failureTable
if (sum(failureTable[, 1] != 0) > 10){
Y <- failureTableModified[which(failureTableModified[, 1] != 0), 5]
X <- as.numeric(rownames(failureTableModified)[which(failureTableModified[, 1] != 0)])
#
# remove the max value
#
X <- X[-which(Y == max(Y))]
Y <- Y[-which(Y == max(Y))]
fit <- lm(Y ~ X)
#
# model:y = ax + b
#
a <- fit$coefficients[2]; b <- fit$coefficients[1]
#
# last di location
#
lastDi <- max(which(failureTable[, 1] != 0))
if (lastDi != nrow(failureTable)){
fr <- a*uniTimePointWithZero[(lastDi+1):nrow(failureTable)] + b
failureTableModified[(lastDi+1):nrow(failureTable), 5] <- fr
}
}
if (sum(failureTable[, 1] == 0) == nrow(failureTable)){
probVector <- probVectorM <- probVectorLower <- probVectorUpper <- rep(0, length(timePoint) - 1)
}else{
#
# ----- Estimation
#
probVector <- 0
for (i in 1:(length(timePoint) - 1)){
probVector[i] <- probMapping(timePoint[i], timePoint[i + 1], 5, failureTable, uniTimePointWithZero)
}
probVectorM <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorM[i] <- probMapping(timePoint[i], timePoint[i + 1], 5, failureTableModified, uniTimePointWithZero)
}
#
# ----- LowerBound
#
probVectorLower <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorLower[i] <- 0
}
#
# ----- UpperBound
#
probVectorUpper <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorUpper[i] <- 0
}
}
lenLimit <- length(which(probVector < 1))
#       timeDiff <- strptime(paste(currentDate, "/01", sep = ""), "%Y/%m/%d") - strptime(rev(x_midCur), "%Y/%m/%d")
timeDiff <- strptime(endtmp[2], "%Y-%m-%d") - strptime(rev(x_midCur), "%Y/%m/%d")
restrict <- which(timeDiff < 900)
#       est <- sum((rev(n_ship) * probVector)[restrict][1:lenLimit], na.rm = T)
est <- sum((rev(n_ship) * probVector)[1:lenLimit][restrict], na.rm = T)
estLower <- sum((rev(n_ship) * probVectorLower)[1:lenLimit][restrict], na.rm = T)
estUpper <- sum((rev(n_ship) * probVectorUpper)[1:lenLimit][restrict], na.rm = T)
#
estM <- sum((rev(n_ship)*probVectorM)[restrict], na.rm = T)
}else{
est = estLower = estUpper = estM = 0
}
return(c(est, estLower, estUpper, estM))
})
return(outtab)
}
rmaNonparametricC <- function(currentDate = currentDate, dataM, alpha = 0.05, minNi = 5, uniqueProduct = uniqueProduct, nList = nList, x_mid = x_mid, x = x){
dataComp_c <- dataM[[2]]
# ----- Make the table, 1st column is time point, 2nd column is attribute.
# ----- 1. attribute = 1 means failure data
# ----- 2. attribute = 2 means censored data in failure sheet
# ----- 3. attribute = 3 means censored data in dat_shipping (need to multiple the amount)
cur <- paste(currentDate, "15", sep = "/")
nListCur <- lapply(1:length(uniqueProduct), function(u){
nList[[u]][1, 1:which(x_mid == cur)]
})
x_midCur <- x_mid[1:which(x_mid == cur)]
xCur <- x[1:which(x_mid == cur)]
endtmp <- seq(as.Date(paste(c(currentDate, "01"), collapse = "/")), length = 2, by = "months")
endCurrent <- endtmp[2]
Est <- EstLower <- EstUpper <- 0
EstM <- EstMw <- 0
outtab <- sapply(1:length(uniqueProduct), function(num){
n_ship <- nListCur[[num]]
proName <- uniqueProduct[num]
##
## for censored
##
lf_nonBroken <- as.numeric(strptime(endCurrent, "%Y-%m-%d") - strptime(x_midCur, "%Y/%m/%d"))
dat_attr3 <- as.data.frame(cbind(lifeTime = lf_nonBroken, attribute = rep("3", length(lf_nonBroken))))
##
## ---- dataComp_c includes all the data, it need to remove the Receive_DT after YMD.
##
dataComp_c_pro <- dataComp_c[which(dataComp_c$Product_Name == proName), ]
part <- which(strptime(endtmp[1], "%Y-%m-%d") - strptime(dataComp_c_pro$Receive_DT, "%Y/%m/%d") > 0)
dataComp_c_part <- dataComp_c_pro[part, ]
if (nrow(dataComp_c_part) >= 3){
lfBreak <- rep(dataComp_c_part$lifeTime, dataComp_c_part$qty)
dat_attr1 <- as.data.frame(cbind(lifeTime = lfBreak, attribute = rep("1", length(lfBreak))))
# to know which month this product is broken
lf_Month <- strptime(endCurrent, "%Y-%m-%d") - strptime(paste(xCur, "01", sep = "/"), "%Y/%m/%d")
belongMonth <- strptime(endCurrent, "%Y-%m-%d") - strptime(dataComp_c_part$MES_Shipping_Dt_withDay, "%Y/%m/%d")
belongTime <- 0
if (length(belongMonth) != 0){
for (i in 1:length(belongMonth)){
belongTime[i] <- lf_nonBroken[max(which(belongMonth[i] <= lf_Month))]
}
}
#
censoredPro <- dat_censored1[which(dat_censored1$Product_Name == proName), ]
if (nrow(censoredPro) != 0){
lf_censored1 <- strptime(rep(currentDate, nrow(censoredPro)), "%Y/%m/%d") - strptime(censoredPro$MES_Shipping_Dt_withDay, "%Y/%m/%d")
##
## ---- Because lf_censored1 is build before input the YMD, so it may include the shipping date after than the YMD, so the value will be negative.
##
lf_censored1_part <- lf_censored1[which(lf_censored1 > 0)]
dat_attr2 <- as.data.frame(cbind(lifeTime = as.numeric(lf_censored1_part), attribute = rep("2", length(lf_censored1_part))))
}else{
dat_attr2 <- NULL
}
tmpTable <- rbind(dat_attr1, dat_attr2, dat_attr3)
tmpTable[, 1] <- as.numeric(as.character(tmpTable[, 1]))
tmpTableOrder <- tmpTable[order(tmpTable[, 1]), ]
ind <- which(strptime(x_mid, "%Y/%m/%d") < strptime(endCurrent, "%Y-%m-%d"))
n <- sum(n_ship[ind])
##
## ----- combine the same lifeTime and same attribute together
##
uniTimePoint <- unique(tmpTableOrder[, 1])
if (uniTimePoint[1] == 0){uniTimePoint <- uniTimePoint[-1]}
failureTable <- matrix(0, ncol = 7, nrow = (length(uniTimePoint) + 1))
failureTable[1, 3] <- n
########
########
########
for (i in 2:(length(uniTimePoint) + 1)){
#for (i in 38:38){
tab <- tmpTableOrder[which(tmpTableOrder[, 1] == uniTimePoint[i - 1]), ]
failureTable[i, 1] <- sum((tab[, 2] == 1))      # di
failureTable[i, 2] <- sum((tab[, 2] == 2))      # ri (in failure data)
# attr == 3
if (3 %in% tab$attribute){
locCensor <- which(lf_nonBroken == tab[1, 1])
nCensor <- n_ship[locCensor]
failureTable[i, 2] <- failureTable[i, 2] + nCensor     # ri (attr 3)
}
}
rownames(failureTable) <- c(0, uniTimePoint)
colnames(failureTable) <- c("di", "ri", "ni", "1-pi", "F(ti)", "Lower", "Upper")
for (l in 1:length(belongTime)){
loc <- which(belongTime[l] == c(0, uniTimePoint))
tmp[l] <- loc
failureTable[loc, 2] <- failureTable[loc, 2] - 1
}
if (min(failureTable[, 2]) < 0){
failureTable[1, 3] <- failureTable[1, 3] - sum(failureTable[which(failureTable[, 2] < 0), 2])
failureTable[which(failureTable[, 2] < 0), 2] <- 0
}
for (i in 2:(length(uniTimePoint) + 1)){
failureTable[i, 3] <- failureTable[i - 1, 3] - sum(failureTable[i - 1, 1] + failureTable[i - 1, 2])    # ni
}
########
########
########
if (min(failureTable[, 3]) < 0){
failureTable[, 3] <- failureTable[, 3] - min(failureTable[, 3])
}
# -----
for (i in 1:nrow(failureTable)){
if (failureTable[i, 1] > 0 & failureTable[i, 3] > 0){
failureTable[i, 4] <- 1 - (failureTable[i, 1] / failureTable[i, 3])
}
}
nonZero <- which(failureTable[, 1] != 0)
if (length(nonZero) == 0){
sti <- 0
fti <- 1
}else{
sti <- numeric(length = length(nonZero) + 1)
sti[1] <- 1
for (j in 2:(length(nonZero) + 1)){
sti[j] <- sti[j - 1] * failureTable[which(rownames(failureTable) == names(nonZero[j - 1])), 4]
}
sti <- sti[-1]
fti <- 1 - sti
}
failureTable[which(failureTable[, 1] != 0), 5] <- fti
nj <- failureTable[which(failureTable[, 1] != 0), 3]
p <- 1 - failureTable[which(failureTable[, 1] != 0), 4]
tmp1 <- p/(n*(1-p))
var_Fti  <- 0
for (i in 1:length(fti)){
var_Fti[i] <- (sti[i])^2*sum(tmp1[1:i])
}
z <- qnorm(1 - alpha)
# ----- 1. log transformation
w <- exp(z*sqrt(var_Fti)/(fti*(1 - fti)))
Fti_Lower <- fti/(fti + (1 - fti)*w)
Fti_Upper <- fti/(fti + (1 - fti)/w)
# ----- 2. large sample (assume it is normal distribution)
#   Fti_Lower <- max(fti - z*sqrt(var_Fti), 0)
#   Fti_Upper <- min(fti + z*sqrt(var_Fti), 1)
failureTable[which(failureTable[, 1] != 0), 6] <- Fti_Lower
failureTable[which(failureTable[, 1] != 0), 7] <- Fti_Upper
failureTable[which(failureTable[, 4] == 0 & failureTable[, 1] > 0), 6:7] <- 1
# ----- If the number of sacrificer are less, it may effect the estimation a lot.(failure probability will too high.)
# ----- It still need discussion.
lastDiLargeN <- which(failureTable[, 3] > minNi & failureTable[, 1] > 0)
if (length(lastDiLargeN) != 0){
for (j in 5:7){
for (m in max(lastDiLargeN):nrow(failureTable)){
failureTable[m, j] <- failureTable[lastDiLargeN[length(lastDiLargeN)], j]
}
}
##
## failureTable has only one di, so the F(ti) will be the same, it will let the prob all be zero.
##
for (j in 5:7){
if (failureTable[1, 1] == 0){
if (length(which(failureTable[, j] > 0)) > 0){
for (r in 2:(min(lastDiLargeN) - 1)){
proportion <- c(0, uniTimePoint)[r]/(c(0, uniTimePoint)[min(lastDiLargeN)])
failureTable[r, 5] <- proportion*failureTable[min(lastDiLargeN), 5]
}
}
}
}
}
## ----- Start to build the process of calculation
## unit: day
## Add the currently ()
timePoint <- rev(c(strptime(endMonth, "%Y-%m-%d") - strptime(colnames(n_ship), "%Y/%m/%d"), 0))
##
## probMapping is a function that can map a given timeRange(tpIni, tpEnd) to failureTable to get the probability.
##
uniTimePointWithZero <- c(0, uniTimePoint)
timePoint <- c(0, rev(lf_nonBroken))
failureTableModified <- failureTable
if (sum(failureTable[, 1] != 0) > 10){
Y <- failureTableModified[which(failureTableModified[, 1] != 0), 5]
X <- as.numeric(rownames(failureTableModified)[which(failureTableModified[, 1] != 0)])
#
# remove the max value
#
X <- X[-which(Y == max(Y))]
Y <- Y[-which(Y == max(Y))]
fit <- lm(Y ~ X)
#
# model:y = ax + b
#
a <- fit$coefficients[2]; b <- fit$coefficients[1]
#
# last di location
#
lastDi <- max(which(failureTable[, 1] != 0))
if (lastDi != nrow(failureTable)){
fr <- a*uniTimePointWithZero[(lastDi+1):nrow(failureTable)] + b
failureTableModified[(lastDi+1):nrow(failureTable), 5] <- fr
}
}
if (sum(failureTable[, 1] == 0) == nrow(failureTable)){
probVector <- probVectorM <- probVectorLower <- probVectorUpper <- rep(0, length(timePoint) - 1)
}else{
#
# ----- Estimation
#
probVector <- 0
for (i in 1:(length(timePoint) - 1)){
probVector[i] <- probMappingC(timePoint[i], timePoint[i + 1], 5, failureTable, uniTimePointWithZero)
}
probVectorM <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorM[i] <- probMappingC(timePoint[i], timePoint[i + 1], 5, failureTableModified, uniTimePointWithZero)
}
#
# ----- LowerBound
#
probVectorLower <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorLower[i] <- 0
}
#
# ----- UpperBound
#
probVectorUpper <- 0
for (i in 1:(length(timePoint) - 1)){
probVectorUpper[i] <- 0
}
}
lenLimit <- length(which(probVector < 1))
#       timeDiff <- strptime(paste(currentDate, "/01", sep = ""), "%Y/%m/%d") - strptime(rev(x_midCur), "%Y/%m/%d")
timeDiff <- strptime(endtmp[2], "%Y-%m-%d") - strptime(rev(x_midCur), "%Y/%m/%d")
restrict <- which(timeDiff < 900)
#       est <- sum((rev(n_ship) * probVector)[restrict][1:lenLimit], na.rm = T)
est <- sum((rev(n_ship) * probVector)[1:lenLimit][restrict], na.rm = T)
estLower <- sum((rev(n_ship) * probVectorLower)[1:lenLimit][restrict], na.rm = T)
estUpper <- sum((rev(n_ship) * probVectorUpper)[1:lenLimit][restrict], na.rm = T)
#
estM <- sum((rev(n_ship)*probVectorM)[restrict], na.rm = T)
}else{
est = estLower = estUpper = estM = 0
}
return(c(est, estLower, estUpper, estM))
})
return(outtab)
}
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
library(rjson)
library(snow)
cl <- makeCluster(4,type="MPI")
varlist <- list("compNameAppear", "dataArrC", "dat_all", "dat_com", "dat_shipping", "dat_future_shipping",
"ymd", "toJSON", "selectNiC", "rmaNonparametricC", "probMappingC")
# varlist <- list("compNameAppear", "dataArrC", "dat_all", "dat_com", "dat_shipping", "dat_future_shipping",
#                 "ymd", "toJSON", "selectNi", "rmaNonparametric", "probMappingC")
clusterExport(cl, varlist, envir = .GlobalEnv)
pt2 <- system.time({
output2 <- parLapply(cl, 1:5, function(pro){
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
#
#     elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC. = rmaNonparametricC)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
return(elected)
})
})
stopCluster(cl)
