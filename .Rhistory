datShipPro_i <- datShipPro[which(datShipPro$Product_Name == uniqueProduct[i]), ]
n_ship <- sapply(1:(length(x_split)), function(j){
return(max(sum(datShipPro_i[which(datShipPro_i$Shipping_DT == x_split[j]), "Qty"]), 0))
})
return(matrix(n_ship, nrow=1))
})
for (l in 1:length(nList)){
colnames(nList[[l]]) <- x_mid[1:(length(x_mid))]
}
names(nList) <- uniqueProduct
dataComp_c <- dataM[[2]]
#########
x <- as.character(sapply(x1, function(y){
tmp <- strsplit(y, "-")[[1]]
tmp[3] <- "01"
tmp2 <- paste(tmp[1], tmp[2], sep="/")
return(tmp2)
}))
if (minD != 1){
x <- c(x, YMD)
}
xDate <- x[1:length(x) - 1]
#----- selection mechanism
tmpEst <- 0
tmpLower <- 0
tmpUpper <- 0
tmpTrendmv <- 0
tmpEstM <- 0
if (length(xDate) < 25){
twoPeriod <- length(xDate)
}else{
twoPeriod <- 24
}
for (i in 2:twoPeriod){
tmpStore <- apply(rmaNonparametricC(xDate[i], dataM, minNi = minNi, uniqueProduct = uniqueProduct, nList = nList, x_mid = x_mid, x = x, endMonth = endMonth), 1, sum)
tmpEst[i] <- tmpStore[1]
tmpLower[i] <- tmpStore[2]
tmpUpper[i] <- tmpStore[3]
tmpTrendmv[i] <- tmpStore[1]
tmpEstM[i] <- tmpStore[4]
if (i > 10){
mean1 <- mean(n_break[(i - 1):(i - 5)])
mean2 <- mean(n_break[(i - 2):(i - 6)])
mean3 <- mean(n_break[(i - 3):(i - 7)])
mean4 <- mean(n_break[(i - 4):(i - 8)])
mean5 <- mean(n_break[(i - 5):(i - 9)])
#-------------------
ft1 <- mean2 - mean1
ft2 <- mean3 - mean2
ft3 <- mean4 - mean3
ft4 <- mean5 - mean4
ftMean <- mean(c(ft1, ft2, ft3, ft4))
tmpTrendmv[i] <- mean(c(mean1 + ftMean,  sum(tmpStore[[1]])))
}
}
if (length(xDate) > 24){
for (i in 25:length(xDate)){
tmpStore <- apply(rmaNonparametricC(xDate[i], dataM, minNi = minNi, uniqueProduct = uniqueProduct, nList = nList, x_mid = x_mid, x = x, endMonth = endMonth), 1, sum)
tmpEst[i] <- tmpStore[1]
tmpLower[i] <- tmpStore[2]
tmpUpper[i] <- tmpStore[3]
tmpTrendmv[i] <- tmpStore[1]
tmpEstM[i] <- tmpStore[4]
#
mean1 <- mean(n_break[(i - 1):(i - 5)])
mean2 <- mean(n_break[(i - 2):(i - 6)])
mean3 <- mean(n_break[(i - 3):(i - 7)])
mean4 <- mean(n_break[(i - 4):(i - 8)])
mean5 <- mean(n_break[(i - 5):(i - 9)])
ft1 <- mean2 - mean1
ft2 <- mean3 - mean2
ft3 <- mean4 - mean3
ft4 <- mean5 - mean4
ftMean <- mean(c(ft1, ft2, ft3, ft4))
tmpTrendmv[i] <- mean(c(mean1 + ftMean,  sum(tmpStore[[1]])))
}
}
EstStorage <- matrix(c(tmpEst, tmpLower, tmpUpper, tmpTrendmv, tmpEstM), ncol = 5)
# -----
Est <- EstStorage[, 1]
Lower <- EstStorage[, 2]
Upper <- EstStorage[, 3]
nb <- c(as.numeric(n_break))
#----
MVTrend <- EstStorage[, 4]
EstModified <- EstStorage[, 5]
dataFrame <- data.frame(x = xDate, nb = nb, Est = Est, Lower = Lower, Upper = Upper,
MVTrend = MVTrend, EstModified = EstModified, Empirical = dataM[[6]])
## use time series to let the estimation close to the truth.
## ind is set as 30, because the frequency in time series is set as 12, it need at least 2 period.
ind <- 30
est.ts <- rep(0, nrow(dataFrame))
numOfTraceback <- 2
if (nrow(dataFrame) >= ind){
est.ts[1:(ind - 1)] <- dataFrame[1:(ind - 1), "EstModified"]
#   current <- which(dataFrame[, 1] == currentDate)
current <- nrow(dataFrame)
if (length(current) == 0){
for (r in ind:nrow(dataFrame)){
tmpTab <- dataFrame[1:(r - 1), ]
endD <- as.character(tmpTab[(r - 1), 1])
enddate <- as.numeric(strsplit(endD[length(endD)], "/")[[1]])
breakTS <- ts(tmpTab[, "nb"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitB <- stl(breakTS, s.window="period")
estTS <- ts(tmpTab[, "EstModified"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitE <- stl(estTS, s.window="period")
diffValue <- (fitE$time.series[, "trend"] - fitB$time.series[, "trend"])
dValue <- mean(diffValue[(length(diffValue) - numOfTraceback):length(diffValue)])
est.ts[r] <- dataFrame[r, "EstModified"] - dValue
}
}else{
for (r in ind:nrow(dataFrame)){
if (r <= current){
tmpTab <- dataFrame[1:(r - 1), ]
endD <- as.character(tmpTab[(r - 1), 1])
enddate <- as.numeric(strsplit(endD[length(endD)], "/")[[1]])
breakTS <- ts(tmpTab[, "nb"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitB <- stl(breakTS, s.window="period")
estTS <- ts(tmpTab[, "EstModified"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitE <- stl(estTS, s.window="period")
diffValue <- (fitE$time.series[, "trend"] - fitB$time.series[, "trend"])
dValue <- mean(diffValue[(length(diffValue) - numOfTraceback):length(diffValue)])
est.ts[r] <- dataFrame[r, "EstModified"] - dValue
}else{
tmpTab <- dataFrame[1:current, ]
endD <- as.character(tmpTab[current, 1])
enddate <- as.numeric(strsplit(endD[length(endD)], "/")[[1]])
breakTS <- ts(tmpTab[, "nb"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitB <- stl(breakTS, s.window="period")
estTS <- ts(tmpTab[, "EstModified"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitE <- stl(estTS, s.window="period")
diffValue <- (fitE$time.series[, "trend"] - fitB$time.series[, "trend"])
dValue <- mean(diffValue[(length(diffValue) - numOfTraceback):length(diffValue)])
est.ts[r] <- dataFrame[r, "EstModified"] - dValue
}
}
}
}
neg <- which(est.ts < 0)
if (length(neg) > 0){est.ts[neg] <- 0}
dataFrame <- cbind(dataFrame, EstTs = est.ts)
#         elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC. = rmaNonparametricC, uniqueProduct = uniqueProduct, nList = nList, x_mid = x_mid, x = x)
#       elected <- matrix(0, ncol = 7, nrow = 1)
}else{
dataFrame <- matrix(0, ncol = 7, nrow = 1)
}
}else{
dataFrame <- matrix(0, ncol = 7, nrow = 1)
}
return(dataFrame)
}
selectNiC <- cmpfun(selectNi2)
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# input1: date
currentDate <- "2015/08" # for simulation
ymd <- "2015/08"        # for last estimation
# input2: component name
listfile <- read.csv("C:\\Users\\David79.Tseng\\Dropbox\\David79.Tseng\\git-respository\\rma-forecasting\\rmaInventoryList.csv", header = TRUE)
compName <- as.character(listfile[, 1])
nonAppearIndex <- which(compName %in% dat_com$PartNumber)
compNameAppear <- compName[nonAppearIndex]
if ("" %in% compNameAppear){compNameAppear <- compNameAppear[-which(compNameAppear == "")]}
library(Rmpi)
library(rjson)
library(snow)
cl <- makeCluster(4,type="MPI")
varlist <- list("compNameAppear", "dataArrC", "dat_all", "dat_com", "dat_shipping", "dat_future_shipping",
"ymd", "toJSON", "selectNiC", "rmaNonparametricC", "probMappingC")
# varlist <- list("compNameAppear", "dataArrC", "dat_all", "dat_com", "dat_shipping", "dat_future_shipping",
#                 "ymd", "toJSON", "selectNi", "rmaNonparametric", "probMappingC")
clusterExport(cl, varlist, envir = .GlobalEnv)
pt2 <- system.time({
output2 <- parLapply(cl, 1:5, function(pro){
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
#
#     elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC. = rmaNonparametricC)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
#
ele <- elected[, c(3, 6, 7, 8, 9)]
# sum of cumulative
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
cumulatedSum <- c(mean(cumulatedNon[len]),
mean(cumulatedEmp[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
temp <- matrix(c(as.character(elected[, 1]), ele[, which(proOfShortage == min(proOfShortage))]), nrow = 2, byrow = T)
out <- toJSON(temp)
})
})
stopCluster(cl)
library(Rmpi)
cl <- makeCluster(4,type="MPI")
cl <- makeCluster(4,type="MPI")
eval
pro = 7
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
ele <- elected[, c(3, 6, 7, 8, 9)]
# sum of cumulative
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
cumulatedSum <- c(mean(cumulatedNon[len]),
mean(cumulatedEmp[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumulatedSum
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
which(proOfShortage == min(proOfShortage))
which(proOfShortage == min(proOfShortage))
which(proOfShortage == min(proOfShortage))
cumulatedSum <- c(mean(cumulatedNon[len]),
mean(cumulatedEmp[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumulatedSum
cumulatedSum > 0
cumulatedSum > 0 & cumulatedSum < 50
which(cumulatedSum > 0 & cumulatedSum < 50)
cumEle <- which(cumulatedSum > 0 & cumulatedSum < 30)
cumEle
which(cumulatedSum > 0 & cumulatedSum < 30)
cumulatedSum
& cumulatedSum < 30
cumEle <- which(cumulatedSum > 0)
cumEle
cumEle <- which(cumulatedSum > 10)
cumEle
cumPositive <- which(cumulatedSum > 10)
cumPositive
sort(cumulatedSum[cumPositive])
cumulatedSum == sort(cumulatedSum[cumPositive])
sort(cumulatedSum[cumPositive])
min(sort(cumulatedSum[cumPositive]))
(sort(cumulatedSum[cumPositive]))[c(1, 2)]
cumPositive <- which(cumulatedSum > 300)
cumPositive
(sort(cumulatedSum[cumPositive]))[c(1, 2)]
cumulatedSum
cumPositive <- which(cumulatedSum > 230)
cumPositive
(sort(cumulatedSum[cumPositive]))[c(1, 2)]
cumPositive <- which(cumulatedSum > 20)
cumPositive <- which(cumulatedSum > 20)
cumPositive
(sort(cumulatedSum[cumPositive]))[c(1, 2)]
cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)]
which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
cumEle
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
which(proOfShortage == min(proOfShortage))
sort(proOfShortage)
sort(proOfShortage)[c(1, 2)]
sort(proOfShortage)[c(1, 2)]
cumEle
proEle <- sort(proOfShortage)[c(1, 2)]
proEle
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
proEle
union(cumEle, proEle)
union(cumEle, proEle)
intersect(cumEle, proEle)
eleFinal <- intersect(cumEle, proEle)
eleFinal
eleFinal
eleFinal
length(eleFinal)
index
proOfShortage
proOfShortage[eleFinal]
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
index
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
index
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
index
eleFinal
cumPositive <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
cumEle
cumPositive <- which(cumulatedSum > 230)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
cumEle
cumPositive
cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)]
cumPositive <- which(cumulatedSum > 250)
cumPositive
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
cumEle
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
eleFinal
cumEle
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
length(eleFinal) > 0
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
cumPositive <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
eleFinal
cumEle
length(proEle) > 0
which(cumulatedSum > 0)
cumulatedSum[which(cumulatedSum > 0) ]
min(cumulatedSum[which(cumulatedSum > 0)])
which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
minCumPos
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
minCumPos
proOfShortage
minShortage
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
}else if (length(minCumPos) > 0){
index <- minCumPos
}else{
index <- 5
}
index
temp <- matrix(c(as.character(elected[, 1]), ele[, which(proOfShortage == min(proOfShortage))]), nrow = 2, byrow = T)
temp
temp <- matrix(c(as.character(elected[, 1]), ele[, which(proOfShortage == min(proOfShortage))]), nrow = 2, byrow = T)
temp
ele[, index]
elected[, 1]
as.character(elected[, 1]), ele[, index]
as.character(elected[, 1])
compName
componentName
c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index])
matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
out <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
out
length(cumulatedEmp)
length(cumulatedNon)
# ----- evaluation function
evalFun <- function(elected, componentName){
ele <- elected[, c(3, 6, 7, 8, 9)]
# sum of cumulative
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
cumulatedSum <- c(mean(cumulatedNon[len]),
mean(cumulatedEmp[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumPositive <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
#
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
minShortage <-
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
}else if (length(minCumPos) > 0){
index <- minCumPos
}else{
index <- 5
}
outMatrix <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
return(outMatrix)
}
#---------------------------------------------------------------------------
out <- evalFun(elected, componentName)
out
pro = 1
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
elected
nrow(elected)
# ----- evaluation function
evalFun <- function(elected, componentName){
if (nrow(elected) > 1){
ele <- elected[, c(3, 6, 7, 8, 9)]
# sum of cumulative
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
cumulatedSum <- c(mean(cumulatedNon[len]),
mean(cumulatedEmp[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumPositive <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
#
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
minShortage <-
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
}else if (length(minCumPos) > 0){
index <- minCumPos
}else{
index <- 5
}
outMatrix <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
}else{
outMatrix <- matrix(componentName, "NoData", "NoData")
}
return(outMatrix)
}
out <- evalFun(elected, componentName)
outMatrix <- matrix(c(componentName, "NoData", "NoData"), nrow= 1)
outMatrix <- matrix(c(componentName, "NoData", "NoData"), nrow = 1)
outMatrix
# ----- evaluation function
evalFun <- function(elected, componentName){
if (nrow(elected) > 1){
ele <- elected[, c(3, 6, 7, 8, 9)]
# sum of cumulative
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
cumulatedSum <- c(mean(cumulatedNon[len]),
mean(cumulatedEmp[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumPositive <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositive]))[c(1, 2)])
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
#
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
minShortage <-
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
}else if (length(minCumPos) > 0){
index <- minCumPos
}else{
index <- 5
}
outMatrix <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
}else{
outMatrix <- matrix(c(componentName, "NoData", "NoData"), nrow = 1)
}
return(outMatrix)
}
out <- evalFun(elected, componentName)
out
library(Rmpi)
cl <- makeCluster(4,type="MPI")
