fitEAll <- stl(estTSAll, s.window="period")
diffValueAll <- (fitEAll$time.series[, "trend"] - fitB$time.series[, "trend"])
dValueAll <- mean(diffValueAll[(length(diffValueAll) - numOfTraceback):length(diffValueAll)])
est.ts.all[r] <- dataFrame[r, "EstModifiedAll"] - dValueAll
}else{
tmpTab <- dataFrame[1:current, ]
endD <- as.character(tmpTab[current, 1])
enddate <- as.numeric(strsplit(endD[length(endD)], "/")[[1]])
breakTS <- ts(tmpTab[, "nb"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitB <- stl(breakTS, s.window="period")
estTS <- ts(tmpTab[, "EstModified"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitE <- stl(estTS, s.window="period")
diffValue <- (fitE$time.series[, "trend"] - fitB$time.series[, "trend"])
dValue <- mean(diffValue[(length(diffValue) - numOfTraceback):length(diffValue)])
est.ts[r] <- dataFrame[r, "EstModified"] - dValue
#
estTSAll <- ts(tmpTab[, "EstModifiedAll"], start=c(minY, minM), end=c(enddate[1], enddate[2]), frequency=12)
fitEAll <- stl(estTSAll, s.window="period")
diffValueAll <- (fitEAll$time.series[, "trend"] - fitB$time.series[, "trend"])
dValueAll <- mean(diffValueAll[(length(diffValueAll) - numOfTraceback):length(diffValueAll)])
est.ts.all[r] <- dataFrame[r, "EstModifiedAll"] - dValueAll
}
}
}
}
neg <- which(est.ts < 0)
if (length(neg) > 0){est.ts[neg] <- 0}
negAll <- which(est.ts.all < 0)
if (length(negAll) > 0){est.ts.all[negAll] <- 0}
dataFrame <- cbind(dataFrame, EstTs = est.ts, EstTsAll = est.ts.all)
#         elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC. = rmaNonparametricC, uniqueProduct = uniqueProduct, nList = nList, x_mid = x_mid, x = x)
#       elected <- matrix(0, ncol = 7, nrow = 1)
}else{
dataFrame <- matrix(0, ncol = 11, nrow = 1)
}
}else{
dataFrame <- matrix(0, ncol = 11, nrow = 1)
}
return(dataFrame)
}
selectNiC <- cmpfun(selectNi2)
ele <- elected[, 3:ncol(elected)]
ele
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
elected
ele <- elected[, 3:ncol(elected)]
ele
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
cumulatedSum <- c(mean(cumulatedNon[len]),
mean(cumulatedEmp[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumPositiveCri <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositiveCri]))[c(1, 2)])
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
#
cumPositive <- cumulatedSum[which(cumulatedSum > 0)]
if (length(cumPositive) > 0){
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
}else{
minCumPos <- integer(0)
}
#
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
if (length(index) > 1){
index <- which(cumulatedSum == min(cumulatedSum[index][which(cumulatedSum[index] > 0)]))
}
}else if (length(minCumPos) > 0){
index <- minCumPos
if (length(minCumPos) > 1){
index <- minCumPos[which(proOfShortage[minCumPos] == min(proOfShortage[minCumPos]))]
}
}else{
index <- 7
}
proOfShortage
index <- minCumPos[which(proOfShortage[minCumPos] == min(proOfShortage[minCumPos]))]
minCumPos
cumulatedSum
ele
index
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
if (length(index) > 1){
index <- which(cumulatedSum == min(cumulatedSum[index][which(cumulatedSum[index] > 0)]))
}
}else if (length(minCumPos) > 0){
index <- minCumPos
if (length(minCumPos) > 1){
index <- minCumPos[which(proOfShortage[minCumPos] == min(proOfShortage[minCumPos]))]
}
}else{
index <- 5
}
index
if (index != 1){indexTransforamtion <- index*2 - 2}
index
indexTransforamtion
if (index != 1){index <- index*2 - 2}
index
index
outMatrix1 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
outMatrix1 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
if (index != 1){
outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index + 1]), ncol = 3)
}else{
outMatrix1.5 <- outMatrix1
}
outMatrix1.5
index
ele
cumulatedSum <- c(mean(cumulatedEmp[len]),
mean(cumulatedNon[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumPositiveCri <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositiveCri]))[c(1, 2)])
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
#
cumPositive <- cumulatedSum[which(cumulatedSum > 0)]
if (length(cumPositive) > 0){
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
}else{
minCumPos <- integer(0)
}
#
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
if (length(index) > 1){
index <- which(cumulatedSum == min(cumulatedSum[index][which(cumulatedSum[index] > 0)]))
}
}else if (length(minCumPos) > 0){
index <- minCumPos
if (length(minCumPos) > 1){
index <- minCumPos[which(proOfShortage[minCumPos] == min(proOfShortage[minCumPos]))]
}
}else{
index <- 5
}
head(ele)
index
if (length(index) > 1){index <- max(index)}
if (index != 1){index <- index*2 - 2}
# temp
outMatrix1 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
if (index != 1){
outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index + 1]), ncol = 3)
}else{
outMatrix1.5 <- outMatrix1
}
outMatrix2 <- matrix(c(componentName,
"LTBIW",
sum(ele[(which(as.character(elected[, 1]) == nowDate) + 1):nrow(elected), index])), ncol = 3)
outMatrix3 <- matrix(c(componentName,
"LTBOOW",
sum(ele[, index])), ncol = 3)
outMatrix <- rbind(outMatrix1, outMatrix1.5, outMatrix2, outMatrix3)
outMatrix
outMatrix1
outMatrix1.5
as.character(elected[, 1])
paste(as.character(elected[, 1]))
outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)),
paste(as.character(elected[, 1]), "out", sep = "_"),
ele[, index + 1]), ncol = 3)
outMatrix1.5
outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)),
paste(as.character(elected[, 1]), "out", sep = "_"),
ele[, index]), ncol = 3)
outMatrix1.5
outMatrix1 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
if (index != 1){
outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)),
paste(as.character(elected[, 1]), "out", sep = "_"),
ele[, index + 1]), ncol = 3)
}else{
outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)),
paste(as.character(elected[, 1]), "out", sep = "_"),
ele[, index]), ncol = 3)
}
outMatrix2 <- matrix(c(componentName,
"LTBIW",
sum(ele[(which(as.character(elected[, 1]) == nowDate) + 1):nrow(elected), index])), ncol = 3)
outMatrix3 <- matrix(c(componentName,
"LTBOOW",
sum(ele[, index])), ncol = 3)
outMatrix <- rbind(outMatrix1, outMatrix1.5, outMatrix2, outMatrix3)
outMatrix
# ----- evaluation function
evalFun <- function(elected, componentName, nowDate = nowDate){
if (nrow(elected) > 1){
ele <- elected[, 3:ncol(elected)]
# sum of cumulative
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
cumulatedSum <- c(mean(cumulatedEmp[len]),
mean(cumulatedNon[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumPositiveCri <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositiveCri]))[c(1, 2)])
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
#
cumPositive <- cumulatedSum[which(cumulatedSum > 0)]
if (length(cumPositive) > 0){
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
}else{
minCumPos <- integer(0)
}
#
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
if (length(index) > 1){
index <- which(cumulatedSum == min(cumulatedSum[index][which(cumulatedSum[index] > 0)]))
}
}else if (length(minCumPos) > 0){
index <- minCumPos
if (length(minCumPos) > 1){
index <- minCumPos[which(proOfShortage[minCumPos] == min(proOfShortage[minCumPos]))]
}
}else{
index <- 5
}
#
if (length(index) > 1){index <- max(index)}
if (index != 1){index <- index*2 - 2}
# temp
outMatrix1 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
if (index != 1){
outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)),
paste(as.character(elected[, 1]), "out", sep = "_"),
ele[, index + 1]), ncol = 3)
}else{
outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)),
paste(as.character(elected[, 1]), "out", sep = "_"),
ele[, index]), ncol = 3)
}
outMatrix2 <- matrix(c(componentName,
"LTBIW",
sum(ele[(which(as.character(elected[, 1]) == nowDate) + 1):nrow(elected), index])), ncol = 3)
outMatrix3 <- matrix(c(componentName,
"LTBOOW",
sum(ele[, index])), ncol = 3)
outMatrix <- rbind(outMatrix1, outMatrix1.5, outMatrix2, outMatrix3)
}else{
outMatrix <- matrix(c(componentName, "NoData", "NoData"), nrow = 1)
}
return(outMatrix)
}
#
output1 <- lapply(1:5, function(pro){
print(pro)
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
out <- evalFun(elected, componentName, nowDate)
return(out)
})
output1
output1 <- lapply(6:10, function(pro){
print(pro)
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
out <- evalFun(elected, componentName, nowDate)
return(out)
})
source("rdata\\allFunctionForAzureML.R")
nowDate <- "2015/05" # for simulation
twoYearDate <- seq(as.Date(paste(c(nowDate, "01"), collapse = "/")), length = 26, by = "months")
ymd <- paste(strsplit(as.character(max(twoYearDate)), "-")[[1]][1:2], collapse = "/")
# input2: component name
listfile <- read.csv("C:\\Users\\David79.Tseng\\Dropbox\\David79.Tseng\\git-respository\\rma-forecasting\\rmaInventoryList.csv", header = TRUE)
save(listfile, file = "C:\\Users\\David79.Tseng\\Dropbox\\David79.Tseng\\git-respository\\rma-forecasting\\rma-forecasting\\rdata\\listfile.RData")
compName <- as.character(listfile[, 1])
nonAppearIndex <- which(compName %in% dat_com$PartNumber)
compNameAppear <- compName[nonAppearIndex]
if ("" %in% compNameAppear){compNameAppear <- compNameAppear[-which(compNameAppear == "")]}
pro = 5
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
source("allFunction.R")
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
out <- evalFun(elected, componentName, nowDate)
out
elected
nowDate
nrow(elected) > 1
ele <- elected[, 3:ncol(elected)]
# sum of cumulative
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
if (length(cumulatedNon) > 5){
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
}else{
len <- c(1:length(cumulatedNon))
}
cumulatedSum <- c(mean(cumulatedEmp[len]),
mean(cumulatedNon[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumPositiveCri <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositiveCri]))[c(1, 2)])
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
#
cumPositive <- cumulatedSum[which(cumulatedSum > 0)]
if (length(cumPositive) > 0){
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
}else{
minCumPos <- integer(0)
}
#
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
if (length(index) > 1){
index <- which(cumulatedSum == min(cumulatedSum[index][which(cumulatedSum[index] > 0)]))
}
}else if (length(minCumPos) > 0){
index <- minCumPos
if (length(minCumPos) > 1){
index <- minCumPos[which(proOfShortage[minCumPos] == min(proOfShortage[minCumPos]))]
}
}else{
index <- 5
}
#
if (length(index) > 1){index <- max(index)}
if (index != 1){index <- index*2 - 2}
# temp
outMatrix1
outMatrix1 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
outMatrix1
ele[, index + 1]
cbind(outMatrix1, ele[, index + 1])
index
cbind(outMatrix1, ele[, index + 1])
outMat1 <- cbind(outMatrix1, ele[, index + 1])
outMat1
outMatrix2 <- matrix(c(componentName,
"LTBIW",
sum(ele[(which(as.character(elected[, 1]) == nowDate) + 1):nrow(elected), index])), ncol = 3)
outMatrix2
outMatrix2 <- matrix(c(componentName,
"LTB",
sum(ele[(which(as.character(elected[, 1]) == nowDate) + 1):nrow(elected), index])), ncol = 3)
outMatrix2
rbind(outMatrix2, sum(ele[, index]))
cbind(outMatrix2, sum(ele[, index]))
outMat2 <- cbind(outMatrix2, sum(ele[, index]))
outMat2
outMatrix <- rbind(outMat1, outMat2)
outMatrix
outMatrix <- matrix(c(componentName, "NoData", "NoData", "NoData"), nrow = 1)
# ----- evaluation function
evalFun <- function(elected, componentName, nowDate = nowDate){
if (nrow(elected) > 1){
ele <- elected[, 3:ncol(elected)]
# sum of cumulative
cumulatedNon <- cumsum(elected[, "Est"] - elected[, "nb"])
cumulatedEmp <- cumsum(elected[, "Empirical"] - elected[, "nb"])
cumulatedMVTrend <- cumsum(elected[, "MVTrend"] - elected[, "nb"])
cumulatedM <- cumsum(elected[, "EstModified"] - elected[, "nb"])
cumulatedTs <- cumsum(elected[, "EstTs"] - elected[, "nb"])
if (length(cumulatedNon) > 5){
len <- c((length(cumulatedNon) - 5):length(cumulatedNon))
}else{
len <- c(1:length(cumulatedNon))
}
cumulatedSum <- c(mean(cumulatedEmp[len]),
mean(cumulatedNon[len]),
mean(cumulatedMVTrend[len]),
mean(cumulatedM[len]),
mean(cumulatedTs[len]))
cumPositiveCri <- which(cumulatedSum > 20)
cumEle <- which(cumulatedSum %in% (sort(cumulatedSum[cumPositiveCri]))[c(1, 2)])
# proportion of shortage
proOfShortage <- c(sum(cumulatedEmp < 0)/length(cumulatedEmp),
sum(cumulatedNon < 0)/length(cumulatedNon),
sum(cumulatedMVTrend < 0)/length(cumulatedMVTrend),
sum(cumulatedM < 0)/length(cumulatedM),
sum(cumulatedTs < 0)/length(cumulatedTs))
proEle <- which(proOfShortage %in% sort(proOfShortage)[c(1, 2)])
eleFinal <- intersect(cumEle, proEle)
#
cumPositive <- cumulatedSum[which(cumulatedSum > 0)]
if (length(cumPositive) > 0){
minCumPos <- which(cumulatedSum == min(cumulatedSum[which(cumulatedSum > 0)]))
}else{
minCumPos <- integer(0)
}
#
if (length(eleFinal) > 0){ # intersect is none
index <- which(proOfShortage == min(proOfShortage[eleFinal]))
if (length(index) > 1){
index <- which(cumulatedSum == min(cumulatedSum[index][which(cumulatedSum[index] > 0)]))
}
}else if (length(minCumPos) > 0){
index <- minCumPos
if (length(minCumPos) > 1){
index <- minCumPos[which(proOfShortage[minCumPos] == min(proOfShortage[minCumPos]))]
}
}else{
index <- 5
}
#
if (length(index) > 1){index <- max(index)}
if (index != 1){index <- index*2 - 2}
# temp
outMatrix1 <- matrix(c(rep(componentName, nrow(ele)), as.character(elected[, 1]), ele[, index]), ncol = 3)
if (index != 1){
outMat1 <- cbind(outMatrix1, ele[, index + 1])
#       outMatrix1.5 <- matrix(c(rep(componentName, nrow(ele)),
#                                paste(as.character(elected[, 1]), "out", sep = "_"),
#                                ele[, index + 1]), ncol = 3)
}else{
outMat1 <- cbind(outMatrix1, ele[, index])
}
outMatrix2 <- matrix(c(componentName,
"LTB",
sum(ele[(which(as.character(elected[, 1]) == nowDate) + 1):nrow(elected), index])), ncol = 3)
outMat2 <- cbind(outMatrix2, sum(ele[, index]))
outMatrix <- rbind(outMat1, outMat2)
}else{
outMatrix <- matrix(c(componentName, "NoData", "NoData", "NoData"), nrow = 1)
}
return(outMatrix)
}
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
print(pro)
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
out <- evalFun(elected, componentName, nowDate)
out
source("rdata\\allFunctionForAzureML.R")
evalFun
save.image("C:/Users/David79.Tseng/Dropbox/David79.Tseng/git-respository/rma-forecasting/rma-forecasting/rdata/allFunctionForAzureMLWorkspace.RData")
nowDate <- "2015/05" # for simulation
twoYearDate <- seq(as.Date(paste(c(nowDate, "01"), collapse = "/")), length = 26, by = "months")
ymd <- paste(strsplit(as.character(max(twoYearDate)), "-")[[1]][1:2], collapse = "/")
# input2: component name
listfile <- read.csv("C:\\Users\\David79.Tseng\\Dropbox\\David79.Tseng\\git-respository\\rma-forecasting\\rmaInventoryList.csv", header = TRUE)
save(listfile, file = "C:\\Users\\David79.Tseng\\Dropbox\\David79.Tseng\\git-respository\\rma-forecasting\\rma-forecasting\\rdata\\listfile.RData")
compName <- as.character(listfile[, 1])
nonAppearIndex <- which(compName %in% dat_com$PartNumber)
compNameAppear <- compName[nonAppearIndex]
if ("" %in% compNameAppear){compNameAppear <- compNameAppear[-which(compNameAppear == "")]}
source("allFunction.R")
output1 <- lapply(6:10, function(pro){
print(pro)
componentName <- compNameAppear[pro]
dataM <- dataArrC(dat_all = dat_all, dat_com = dat_com, dat_shipping = dat_shipping, dat_future_shipping = dat_future_shipping, componentName = componentName, YMD = ymd)
elected <- selectNiC(dataM = dataM, YMD = ymd, minNi = 5, rmaNonparametricC = rmaNonparametricC)
out <- evalFun(elected, componentName, nowDate)
return(out)
})
outTest <- do.call(rbind, output1)
outTest
